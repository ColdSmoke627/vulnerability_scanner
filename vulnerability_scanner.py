#MODULES
import urllib2
from datetime import datetime
import gzip
import os
import argparse
import progressbar
import sqlite3
from lxml import etree
from termcolor import colored
import requests
import re
import dateutil.parser
from lxml import html
import time, random

#OPTIONS
parser = argparse.ArgumentParser()
parser.add_argument("-s","--software_cpes", help="Finds matching cpes for your packages and stores it.",action="store_true")
parser.add_argument("-n","--nvd_update", help="Updates the cve and cpe information in database.",action="store_true")
parser.add_argument("-v","--vuln_scan", help="Starts vulnerability scan for the software stored in db.",action="store_true")
args = parser.parse_args()

#NVD FEEDS
cpelist = 'http://static.nvd.nist.gov/feeds/xml/cpe/dictionary/official-cpe-dictionary_v2.2.xml.gz'
cpemeta = 'https://static.nvd.nist.gov/feeds/xml/cpe/dictionary/official-cpe-dictionary_v2.2.meta'
dllist = ['https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-Modified.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-Recent.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2002.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2003.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2004.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2005.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2006.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2007.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2008.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2009.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2010.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2011.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2012.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2013.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2014.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2015.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2016.xml.gz',\
				'https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2017.xml.gz']
metalist = ['https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-Modified.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-Recent.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2002.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2003.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2004.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2005.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2006.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2007.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2008.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2009.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2010.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2011.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2012.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2013.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2014.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2015.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2016.meta',\
				'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-2017.meta',]

#DATABASE
def init_database():

	conn = sqlite3.connect('vul.db')
	c = conn.cursor()

	c.execute('''CREATE TABLE IF NOT EXISTS cpes (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	string TEXT, 
	os TEXT,
	vendor TEXT,
	product TEXT,
	version TEXT,
	update_date TEXT,
	edition TEXT,
	language TEXT)''')
	
	c.execute('''CREATE TABLE IF NOT EXISTS software (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	string TEXT,
	package TEXT,
	vendor TEXT,
	product TEXT,
	version TEXT,
	cpe_found TEXT,
	maybe_wrong_vendor TEXT)''')

	c.execute('''CREATE TABLE IF NOT EXISTS cves (
	cveid STRING,
	cvss FLOAT,
	access_vector STRING,
	access_complexity STRING,
	authentication STRING,
	confidentiality_impact STRING,
	integrity_impact STRING,
	availability_impact STRING,
	description STRING,
	published INTEGER,
	modified INTEGER,
	link STRING,
	PRIMARY KEY (cveid))''')

	c.execute('''CREATE TABLE IF NOT EXISTS download_dates(
	link STRING,
	last_download INTEGER,
	PRIMARY KEY (link))''')

	c.execute('''CREATE TABLE IF NOT EXISTS cpe_cve(
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	cpe STRING,
	cveid STRING,
	FOREIGN KEY (cveid) REFERENCES cves(cveid))''')

	c.execute('''CREATE TABLE IF NOT EXISTS scanresult (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	software_id TEXT,
	cve_id TEXT,
	FOREIGN KEY(software_id) REFERENCES software(id),
	FOREIGN KEY(cve_id) REFERENCES cves(cveid))''')

	return conn, c

#DOWNLOAD FUNCTION
def download_xml_data (file):
	url = file
	file_name = url.split('/')[-1]
	u = urllib2.urlopen(url)
	f = open(file_name, 'wb')
	meta = u.info()
	file_size = int(meta.getheaders("Content-Length")[0])
	print str(datetime.now()).split('.')[0] + "\t" + " Downloading: %s Bytes: %s" % (file_name, file_size)

	file_size_dl = 0
	block_sz = 8192
	while True:
		buffer = u.read(block_sz)
		if not buffer:
			break
		file_size_dl += len(buffer)
		f.write(buffer)
		status = r"%10d [%3.2f%%]" % (file_size_dl, file_size_dl * 100. / file_size)
		status = status + chr(8)*(len(status)+1)
		print status,
	f.close()
	return file_name

#DELETE FUNCTION
def delete_file(file_name):
	if os.path.isfile('./' + file_name):
		#print str(datetime.now()).split('.')[0] + "\t" + 'Delete downloaded file ' + file_name
		os.remove('./' + file_name)

#LOG LAST FEED DOWNLOAD
def import_download_date(link,last_download):
	results = c.execute('''SELECT last_download FROM download_dates WHERE link = ?''',(link,))
	result = results.fetchall()
	if not result:
		c.execute('''INSERT INTO download_dates(link,last_download) VALUES (?,?)''',(link,last_download))
	else:
		c.execute('''UPDATE download_dates SET last_download = ? WHERE link = ?''', (last_download,link))
	conn.commit()

#CHECK IF FEED NEEDS UPDATE
def feed_needs_update(link, metadata):
	r = requests.get(metadata)
	regex_last_mod = re.compile(r'lastModifiedDate:(.*)')
	updated = regex_last_mod.findall(r.text)
	updated = updated[0].strip('\t\r\n')
	datetime = dateutil.parser.parse(updated)
	updatedepoch = int(time.mktime(datetime.timetuple()))
	
	result = c.execute('''SELECT last_download FROM download_dates WHERE link = ?''',(link,)).fetchall()
	if result:
		last_download = int(result[0][0])
		if last_download < updatedepoch:
			import_download_date(link,updatedepoch)
			return True

		else:
			return False
	else:
		import_download_date(link,updatedepoch)
		return True


#GET PACKAGES
def get_package_list():

	print 'Starting...'
	print 'Get list of installed packages...'
	#dpkg-query -W -f='${Package} ${Version} ${Architecture}\n' > paket_list.txt
	bashCommand = "bash generate.sh && exit 0"
	import subprocess
	process = subprocess.Popen(bashCommand.split(), stdout=subprocess.PIPE)
	output, error = process.communicate()
	print 'Saved package list to package_list.txt!'

	print 'Opening file package_list.txt...'
	with open('package_list.txt') as f:
		file = [x.replace('\n','').split(" ") for x in f.readlines()]
	return file

#OPEN PACKAGE FILE GENERATED BY generate.sh
def open_package_list(filename):
	with open(filename) as f:
		file = [x.replace('\n','').split(" ") for x in f.readlines()]
	return file

#UPDATE CPE DICT
def update_cpes():
	file_name = ''
	cpe_list = []
	result = c.execute('''SELECT * FROM cpes''').fetchall()
	last_download = c.execute('SELECT last_download FROM download_dates WHERE link = ?',(cpelist,)).fetchall()

	if feed_needs_update(cpelist,cpemeta):
		url = cpelist
		file_name = download_xml_data(url)
		dlname = cpelist.split('/')[-1]
		g = gzip.open(file_name,"rb")
		metadata_contents = g.read()
		g.close()
		g = None
		node = etree.fromstring(metadata_contents)
		cpe_list = node.xpath('//t:cpe-item/@name', namespaces={'t':'http://cpe.mitre.org/dictionary/2.0'})

	if len(cpe_list) > 0:
		c.execute('DELETE FROM cpes')
		print ''
		print 'Importing CPE Dictionary...'
		bar = progressbar.ProgressBar(maxval=len(cpe_list), \
		    widgets=[progressbar.Bar('#', '[', ']'), ' ', progressbar.Percentage()])
		bar.start()
		i = 0
		for cpe in cpe_list:
			#print cpe
			update_date = ''
			edition = ''
			language = ''
			string = cpe.replace('cpe:/','')
			os_bool = string.split(':')[0]
			vendor = string.split(':')[1]
			product = string.split(':')[2]
			version = string.split(':')[3]
			try:
				update_date = string.split(':')[4]
				edition = string.split(':')[5]
				language = string.split(':')[6]
				bar.update(i+1)
			except:
				bar.update(i+1)
				#print 'No other attributes defined'
			string = 'cpe:/' + string
			c.execute('''INSERT INTO cpes 
				(string, 
				os, 
				vendor, 
				product, 
				version, 
				update_date, 
				edition, 
				language)
				VALUES (?,?,?,?,?,?,?,?)''',(string, os_bool, vendor, product, version, update_date, edition, language))
			i += 1
		conn.commit()
		bar.finish()

	delete_file(file_name)

#FIND CPES FOR PACKAGES
def find_cpes(file):
	print 'Scan packages for matched cpes...'
	bar = progressbar.ProgressBar(maxval=len(file), \
	    widgets=[progressbar.Bar('#', '[', ']'), ' ', progressbar.Percentage()])
	bar.start()
	i = 0
	for package in file:
		bar.update(i+1)
		vendor = package[0].split('-')[0]
		#product_string = package[0].replace('-','_')
		product_string = package[0].split('-')[0]
		product = product_string
		version_string = package[1]
		version_string = version_string.split('+')[0]
		version_string = version_string.split('-')[0]
		version_string = version_string.split('~')[0]
		if len(version_string.split(':')) > 1:
			version = version_string.split(':')[1]
		else:
			version = version_string
		#print 'Searching CPE for \t %s:%s:%s' % (vendor,product,version)
		#print version
		edition = package[2]
		result =c.execute('''SELECT DISTINCT vendor, product FROM cpes WHERE vendor = ? AND product = ?''',(vendor,product))
		result2 = result.fetchall()
		if not len(result2) > 0:
			result2a = c.execute('''SELECT DISTINCT vendor, product FROM cpes WHERE product = ?''',(product,))
			result2a = result2a.fetchall()
			if len(result2a) == 1:
				vendor = result2a[0][0]
				#print colored('Found vendor:product:\t%s:%s' % (result2a[0][0],result2a[0][1]), 'yellow')
			#Should be optional because of more false positives
			#if len(result2a) > 1:
				#print 'Multiple options'
				#for result in result2a:
				#	print '%s:%s' % (result[0],result[1])
			#	vendor = result2a[0][0]
		#else:
		#	print colored('Found vendor:product:\t%s:%s' % (result2[0][0],result2[0][1]),'yellow')

		result =c.execute('''SELECT string FROM cpes WHERE vendor = ? AND product = ? AND version = ?''',(vendor,product,version))
		result3 = result.fetchall()
		result = c.execute('''SELECT * FROM software WHERE vendor = ? AND product = ?''',(vendor,product)) #check version for multiple version of package
		result4 = result.fetchall()
		if len(result3) > 0:
			if len(result4) == 0:
				if len(result2a) > 0:
					c.execute('''INSERT INTO software (string, package, vendor,product,version,cpe_found,maybe_wrong_vendor) VALUES (?,?,?,?,?,?,?)''',(result3[0][0],package[0]+" "+package[1]+" "+package[2],vendor,product,version,'1','1'))
				else:
					c.execute('''INSERT INTO software (string, package, vendor,product,version,cpe_found,maybe_wrong_vendor) VALUES (?,?,?,?,?,?,?)''',(result3[0][0],package[0]+" "+package[1]+" "+package[2],vendor,product,version,'1','0'))
			#print colored('Possibly vulnerable:\t%s' % result3[0][0],'red')
		else:
			if len(result2) > 0 or len(result2a) > 0:
				if len(result4) == 0:
					if len(result2a) > 0:
						c.execute('''INSERT INTO software (string, package, vendor,product,version,cpe_found,maybe_wrong_vendor) VALUES (?,?,?,?,?,?,?)''',('cpe:/a:%s:%s:%s' % (vendor,product,version),package[0]+" "+package[1]+" "+package[2], vendor,product,version,'0','1'))
					else:
						c.execute('''INSERT INTO software (string, package, vendor,product,version,cpe_found,maybe_wrong_vendor) VALUES (?,?,?,?,?,?,?)''',('cpe:/a:%s:%s:%s' % (vendor,product,version),package[0]+" "+package[1]+" "+package[2] ,vendor,product,version,'0','0'))
				#print colored('No vuls for version:\t%s' % version, 'green')
		i += 1
	conn.commit()
	bar.finish()

#OUPPUT FOUND CPES
def print_cpes():
	results = c.execute('''SELECT DISTINCT vendor,product,version FROM software WHERE cpe_found = "1"''').fetchall()
	for result in results:
		cpe = 'cpe:/a:%s:%s:%s' % (result[0],result[1],result[2])
		print cpe

#NVD UPDATE
def update_cve_db():
	print 'Updating vulnerability information...'
	for idx, metadata in enumerate(metalist):
		r = requests.get(metadata)
		regex_last_mod = re.compile(r'lastModifiedDate:(.*)')
		updated = regex_last_mod.findall(r.text)
		updated = updated[0].strip('\t\r\n')
		datetime = dateutil.parser.parse(updated)
		updatedepoch = int(time.mktime(datetime.timetuple()))
		feed_tmp = dllist[idx].split('.xml.gz')[0]
		feed = feed_tmp.split('https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-')[-1]
		dllink = dllist[idx]
		results = c.execute('''SELECT last_download FROM download_dates WHERE link = ?''',(dllink,))
		result = results.fetchall()
		if result:
			last_download = int(result[0][0])
			if last_download < updatedepoch:
				import_download_date(dllink,updatedepoch)
				import_cves(dllink)
			else:
				print str(datetime.now()).split('.')[0] + "\t" + feed + "\t" + "Already up-to-date."
		else:
			import_download_date(dllink,updatedepoch)
			import_cves(dllink)

#IMPORT CVE FEED
def import_cves(dllink):

	url = dllink
	file_name = download_xml_data(url)
	dlname = dllink.split('/')[-1]
	g = gzip.open(file_name,"rb")
	gcontent = g.read()
	g.close()
	g = None
	print str(datetime.now()).split('.')[0] + "\t" + "Now, importing content of the file %s" % dlname
	ifxml = etree.XML(gcontent)
	gcontent = None
	bar = progressbar.ProgressBar(maxval=len(ifxml.getchildren()), \
	    widgets=[progressbar.Bar('#', '[', ']'), ' ', progressbar.Percentage()])
	bar.start()
	i = 0
	for entry in ifxml.getchildren():
				cve_id = access_vector = access_complexity = authentication = confidentiality_impact = integrity_impact = availability_impact = description = cwe = ""
				cvss_score = 0.0
				cpetextlist = []
				modified = published = ""

				cveide = entry.find("{http://scap.nist.gov/schema/vulnerability/0.4}cve-id")
				if cveide is not None:
					cve_id = cveide.text
				#cwee = entry.find("{http://scap.nist.gov/schema/vulnerability/0.4}cwe")
				#if cwee is not None:
				#	cwe = cwee.values()[0]

				cvsseleme =entry.find("{http://scap.nist.gov/schema/vulnerability/0.4}cvss") 
				if cvsseleme is not None:
					cvsselem = cvsseleme.getchildren()[0]
					cvss_score = float(cvsselem.find("{http://scap.nist.gov/schema/cvss-v2/0.2}score").text)
					access_vector = cvsselem.find("{http://scap.nist.gov/schema/cvss-v2/0.2}access-vector").text
					access_complexity = cvsselem.find("{http://scap.nist.gov/schema/cvss-v2/0.2}access-complexity").text
					authentication = cvsselem.find("{http://scap.nist.gov/schema/cvss-v2/0.2}authentication").text
					confidentiality_impact = cvsselem.find("{http://scap.nist.gov/schema/cvss-v2/0.2}confidentiality-impact").text
					integrity_impact = cvsselem.find("{http://scap.nist.gov/schema/cvss-v2/0.2}integrity-impact").text
					availability_impact = cvsselem.find("{http://scap.nist.gov/schema/cvss-v2/0.2}availability-impact").text
	
				modifiede = entry.find("{http://scap.nist.gov/schema/vulnerability/0.4}last-modified-datetime")
				if modifiede is not None:
					modified = modifiede.text
					#print modified
    	               
				publishede = entry.find("{http://scap.nist.gov/schema/vulnerability/0.4}published-datetime")
				if publishede is not None:
					published = publishede.text

				summarye = entry.find("{http://scap.nist.gov/schema/vulnerability/0.4}summary")
				if summarye is not None:
					description = summarye.text
	
				cpeliste = entry.find("{http://scap.nist.gov/schema/vulnerability/0.4}vulnerable-software-list")
				if cpeliste is not None:
					for cpee in cpeliste.getchildren():
						cpetextlist.append(cpee.text)
				published_date=published.split(".")[0]
				modified_date=modified.split(".")[0]
				pubepoch=int(time.mktime((time.strptime(published_date,"%Y-%m-%dT%H:%M:%S"))))
				modepoch=int(time.mktime((time.strptime(modified_date,"%Y-%m-%dT%H:%M:%S"))))
				link = 'https://nvd.nist.gov/vuln/detail/' + cve_id
				results = c.execute('''SELECT modified FROM cves WHERE cveid = ?''',(cve_id,))
				result = results.fetchall()
				if result:
					if modified > int(result[0][0]):
						#print 'Updating %s' % (cve_id)
						c.execute('''UPDATE cves SET cvss = ?, access_vector = ?, access_complexity = ?,
									authentication = ?, confidentiality_impact = ?,
									integrity_impact = ?, availability_impact = ?,
									description = ?, published = ?, modified = ? WHERE cveid = ?''',(cvss_score,access_vector,access_complexity,authentication,confidentiality_impact,integrity_impact,availability_impact,description,pubepoch,modepoch,cve_id))
						c.execute('''DELETE FROM cpe_cve WHERE cveid = ?''',(cve_id,))
						for cpe in cpetextlist:
							c.execute('''INSERT INTO cpe_cve (cpe,cveid) VALUES (?,?)''',(cpe,cve_id))
					#else:
						#print '%s is up-to-date.' % (cve_id)
				else:
					#print 'Importing %s' % (cve_id)
					c.execute('''INSERT INTO cves (cvss,access_vector,access_complexity,authentication,confidentiality_impact,integrity_impact,availability_impact,description,published,modified,cveid,link) VALUES (?,?,?,?,?,?,?,?,?,?,?,?)''',(cvss_score,access_vector,access_complexity,authentication,confidentiality_impact,integrity_impact,availability_impact,description,pubepoch,modepoch,cve_id,link))
					for cpe in cpetextlist:
						c.execute('''INSERT INTO cpe_cve (cpe,cveid) VALUES (?,?)''',(cpe,cve_id))
				bar.update(i+1)
				i += 1
	bar.finish()
	conn.commit()
	if os.path.isfile('./' + file_name):
		#print str(datetime.now()).split('.')[0] + "\t" + 'Delete downloaded file ' + file_name
		os.remove('./' + file_name)

# VULNERABILITY SCAN
def scan_software():
	print 'Scanning packages for vulnerabilities...'
	software_list = c.execute('SELECT id, string FROM software').fetchall()
	bar = progressbar.ProgressBar(maxval=len(software_list), \
	    widgets=[progressbar.Bar('#', '[', ']'), ' ', progressbar.Percentage()])
	i = 0
	bar.start()
	for software in software_list:
		id = software[0]
		cpe = software[1]
		result = c.execute('SELECT cveid FROM cpe_cve WHERE cpe = ?',(cpe,)).fetchall()

		#print 'Scanned software with id %s (%s)' % (id,cpe)
		for cve in result:
			cveid = cve[0]
			result = c.execute('SELECT * FROM scanresult WHERE software_id = ? AND cve_id = ?',(id,cveid)).fetchall()
			if len(result) == 0:
				#print colored('Found vulnerability %s' % cve[0],'red')
				c.execute('INSERT INTO scanresult (software_id,cve_id) VALUES (?,?)',(id,cveid))

		conn.commit()
		bar.update(i+1)
		i += 1
	bar.finish()

def print_vuls():
	result = c.execute('''SELECT cveid, string, package, cvss, link, description FROM scanresult
	LEFT JOIN software ON scanresult.software_id = software.id
	LEFT JOIN cves ON scanresult.cve_id = cves.cveid
	ORDER BY cvss,cveid ASC''').fetchall()
	if len(result) > 0:
		print 'Found vulnerabilities:'
		for vul in result:
			print vul[0],vul[1],vul[2],vul[3],vul[4]
	else:
		print 'No vulnerabilities found.'

if __name__ == '__main__':
	conn, c = init_database()
	#NO OPTIONS
	if not args.software_cpes and not args.nvd_update and not args.vuln_scan:
		update_cpes()
		find_cpes(get_package_list())
		#find_cpes(open_package_list(filename))
		print_cpes()
		update_cve_db()
		scan_software()
		print_vuls()
	#WITH OPTIONS
	else:
		if args.software_cpes:
			update_cpes()
			find_cpes(get_package_list())
			#find_cpes(open_package_list(filename))
			print_cpes()
		if args.nvd_update:
			update_cve_db()
		if args.vuln_scan:
			scan_software()
			print_vuls()